# æ–‡æ¡£åŸºç¡€ç¼–è¾‘åŠŸèƒ½å‰ç«¯è®¾è®¡æ–‡æ¡£

**åŠŸèƒ½æ¨¡å—**: æ–‡æ¡£åŸºç¡€ç¼–è¾‘ (US-001, US-002)
**ç‰ˆæœ¬**: 1.0.0
**æœ€åæ›´æ–°**: 2025-01-16

---

## ğŸ“‹ ç›®å½•

1. [åŠŸèƒ½éœ€æ±‚](#åŠŸèƒ½éœ€æ±‚)
2. [å½“å‰å®ç°çŠ¶æ€](#å½“å‰å®ç°çŠ¶æ€)
3. [ç¼ºå¤±åŠŸèƒ½è®¾è®¡](#ç¼ºå¤±åŠŸèƒ½è®¾è®¡)
4. [æŠ€æœ¯å®ç°æ–¹æ¡ˆ](#æŠ€æœ¯å®ç°æ–¹æ¡ˆ)
5. [APIå¯¹æ¥](#apiå¯¹æ¥)
6. [æ€§èƒ½ä¼˜åŒ–](#æ€§èƒ½ä¼˜åŒ–)

---

## åŠŸèƒ½éœ€æ±‚

### US-001: æ‰‹åŠ¨åˆ›å»ºå¹¶ç¼–è¾‘æ–‡æ¡£

**éªŒæ”¶å‡†åˆ™**:

1. âœ… åˆ›å»ºç©ºç™½æ–‡æ¡£ï¼Œé»˜è®¤æ ‡é¢˜"Untitled Document"
2. âœ… æ–‡æœ¬è¾“å…¥/åˆ é™¤/ä¿®æ”¹ï¼Œå…‰æ ‡ä½ç½®å®æ—¶å“åº”ï¼ˆå»¶è¿Ÿâ‰¤100msï¼‰
3. âš ï¸ **åŸºç¡€æ ¼å¼è°ƒæ•´**ï¼šæ ‡é¢˜ï¼ˆH1-H6ï¼‰ã€ç²—ä½“/æ–œä½“/ä¸‹åˆ’çº¿ã€æœ‰åº/æ— åºåˆ—è¡¨ã€ä»£ç å—
4. âœ… ç¼–è¾‘å†…å®¹5ç§’å†…è‡ªåŠ¨åŒæ­¥è‡³äº‘ç«¯
5. âœ… æ”¯æŒæ‰‹åŠ¨è§¦å‘"ä¿å­˜"æŒ‰é’®
6. âŒ **æ’¤é”€/é‡åš**ï¼šè‡³å°‘ä¿ç•™50æ­¥æ“ä½œè®°å½•

### US-002: æ–‡æ¡£æ ¼å¼é¢„è§ˆä¸æ’ç‰ˆä¼˜åŒ–

**éªŒæ”¶å‡†åˆ™**:

1. âŒ **é¢„è§ˆæ¨¡å¼åˆ‡æ¢**
2. âŒ **æ®µè½é—´è·è°ƒæ•´ã€æ–‡æœ¬å¯¹é½**
3. âš ï¸ **ä»£ç å—è¯­æ³•é«˜äº®**ï¼ˆè‡³å°‘è¦†ç›–TS/JS/HTML/CSS/Markdownï¼‰
4. âŒ **æ ¼å¼è°ƒæ•´åå®æ—¶ç”Ÿæ•ˆ**

---

## å½“å‰å®ç°çŠ¶æ€

### âœ… å·²å®ç°

| åŠŸèƒ½       | å®ç°ä½ç½®                | çŠ¶æ€                             |
| ---------- | ----------------------- | -------------------------------- |
| å—ç±»å‹æ”¯æŒ | `blocksuite-editor.tsx` | æ®µè½ã€æ ‡é¢˜ã€åˆ—è¡¨ã€ä»£ç å—ã€åˆ†å‰²çº¿ |
| å— CRUD    | `blocksuite-editor.tsx` | å®Œæ•´å®ç°                         |
| è‡ªåŠ¨ä¿å­˜   | `blocksuite-editor.tsx` | 1ç§’å»¶è¿Ÿä¿å­˜åˆ° localStorage       |
| å—ç±»å‹è½¬æ¢ | `blocksuite-editor.tsx` | åŸºç¡€æ”¯æŒ                         |
| å­—ç¬¦ç»Ÿè®¡   | `blocksuite-editor.tsx` | å·²å®ç°                           |

### âŒ ç¼ºå¤±åŠŸèƒ½

| åŠŸèƒ½                               | ä¼˜å…ˆçº§ | å½±å“èŒƒå›´     |
| ---------------------------------- | ------ | ------------ |
| **æ’¤é”€/é‡åš**                      | ğŸ”´ é«˜  | æ ¸å¿ƒç”¨æˆ·ä½“éªŒ |
| **å¯Œæ–‡æœ¬æ ¼å¼**ï¼ˆç²—ä½“/æ–œä½“/ä¸‹åˆ’çº¿ï¼‰ | ğŸ”´ é«˜  | åŸºç¡€ç¼–è¾‘éœ€æ±‚ |
| **é¢„è§ˆæ¨¡å¼**                       | ğŸŸ¡ ä¸­  | ç”¨æˆ·ä¾¿åˆ©æ€§   |
| **æ®µè½é—´è·/å¯¹é½**                  | ğŸŸ¡ ä¸­  | æ’ç‰ˆç¾è§‚     |
| **ä»£ç è¯­æ³•é«˜äº®**                   | ğŸŸ¡ ä¸­  | å¼€å‘è€…ä½“éªŒ   |

---

## ç¼ºå¤±åŠŸèƒ½è®¾è®¡

### 1. æ’¤é”€/é‡åšåŠŸèƒ½

#### è®¾è®¡æ–¹æ¡ˆ

**æ¶æ„é€‰æ‹©**: ä½¿ç”¨å‘½ä»¤æ¨¡å¼ï¼ˆCommand Patternï¼‰

```typescript
// src/web/editor/commands.ts

/**
 * ç¼–è¾‘å‘½ä»¤æ¥å£
 */
interface EditorCommand {
  execute(): void | Promise<void>;
  undo(): void | Promise<void>;
  canExecute(): boolean;
}

/**
 * æ–‡æœ¬æ’å…¥å‘½ä»¤
 */
class InsertTextCommand implements EditorCommand {
  constructor(
    private editor: BlocksuiteEditor,
    private blockId: string,
    private text: string,
    private position: number
  ) {}

  execute() {
    const block = this.editor.getBlock(this.blockId);
    this.originalContent = block.content;
    block.content = block.content.slice(0, this.position) + this.text + block.content.slice(this.position);
  }

  undo() {
    const block = this.editor.getBlock(this.blockId);
    block.content = this.originalContent;
  }

  canExecute(): boolean {
    return !!this.editor.getBlock(this.blockId);
  }
}

/**
 * å—åˆ é™¤å‘½ä»¤
 */
class DeleteBlockCommand implements EditorCommand {
  // ... ç±»ä¼¼å®ç°
}

/**
 * å—æ ¼å¼æ›´æ”¹å‘½ä»¤
 */
class ChangeFormatCommand implements EditorCommand {
  // ... ç±»ä¼¼å®ç°
}
```

**å†å²æ ˆç®¡ç†å™¨**:

```typescript
// src/web/editor/history-manager.ts

export class HistoryManager {
  private undoStack: EditorCommand[] = [];
  private redoStack: EditorCommand[] = [];
  private maxSize = 50; // æœ€å¤šä¿ç•™50æ­¥

  // æ‰§è¡Œå‘½ä»¤
  async execute(command: EditorCommand) {
    if (!command.canExecute()) return;

    await command.execute();

    // æ·»åŠ åˆ°æ’¤é”€æ ˆ
    this.undoStack.push(command);

    // é™åˆ¶æ ˆå¤§å°
    if (this.undoStack.length > this.maxSize) {
      this.undoStack.shift();
    }

    // æ¸…ç©ºé‡åšæ ˆï¼ˆæ–°æ“ä½œä½¿ä¹‹å‰çš„é‡åšå¤±æ•ˆï¼‰
    this.redoStack = [];
  }

  // æ’¤é”€
  async undo() {
    const command = this.undoStack.pop();
    if (command) {
      await command.undo();
      this.redoStack.push(command);
    }
  }

  // é‡åš
  async redo() {
    const command = this.redoStack.pop();
    if (command) {
      await command.execute();
      this.undoStack.push(command);
    }
  }

  // æ£€æŸ¥æ˜¯å¦å¯ä»¥æ’¤é”€
  canUndo(): boolean {
    return this.undoStack.length > 0;
  }

  // æ£€æŸ¥æ˜¯å¦å¯ä»¥é‡åš
  canRedo(): boolean {
    return this.redoStack.length > 0;
  }

  // æ¸…ç©ºå†å²
  clear() {
    this.undoStack = [];
    this.redoStack = [];
  }

  // ä¿å­˜æ£€æŸ¥ç‚¹ï¼ˆç”¨äºæ‰‹åŠ¨ä¿å­˜ï¼‰
  createCheckpoint(): string {
    const id = generateId();
    // ä¿å­˜å½“å‰çŠ¶æ€å¿«ç…§
    return id;
  }

  // æ¢å¤åˆ°æ£€æŸ¥ç‚¹
  restoreCheckpoint(checkpointId: string) {
    // æ¢å¤åˆ°æŒ‡å®šæ£€æŸ¥ç‚¹
  }
}
```

**é›†æˆåˆ°ç¼–è¾‘å™¨**:

```typescript
// src/web/components/blocksuite-editor.tsx

export const BlocksuiteEditor: React.FC<Props> = ({ docId }) => {
  const history = useRef(new HistoryManager());

  // é”®ç›˜å¿«æ·é”®
  useEffect(() => {
    const handleKeyDown = (e: KeyboardEvent) => {
      // Ctrl+Z: æ’¤é”€
      if ((e.ctrlKey || e.metaKey) && e.key === 'z' && !e.shiftKey) {
        e.preventDefault();
        history.current.undo();
      }

      // Ctrl+Shift+Z æˆ– Ctrl+Y: é‡åš
      if (
        ((e.ctrlKey || e.metaKey) && e.shiftKey && e.key === 'z') ||
        ((e.ctrlKey || e.metaKey) && e.key === 'y')
      ) {
        e.preventDefault();
        history.current.redo();
      }
    };

    document.addEventListener('keydown', handleKeyDown);
    return () => document.removeEventListener('keydown', handleKeyDown);
  }, []);

  // åŒ…è£…æ‰€æœ‰ç¼–è¾‘æ“ä½œ
  const insertText = (blockId: string, text: string, position: number) => {
    const command = new InsertTextCommand(editorRef.current, blockId, text, position);
    history.current.execute(command);
  };

  const deleteBlock = (blockId: string) => {
    const command = new DeleteBlockCommand(editorRef.current, blockId);
    history.current.execute(command);
  };

  // æš´éœ²æ’¤é”€/é‡åšçŠ¶æ€
  const canUndo = history.current.canUndo();
  const canRedo = history.current.canRedo();

  return (
    <div className="editor-container">
      {/* å·¥å…·æ  */}
      <Toolbar>
        <ToolbarButton
          disabled={!canUndo}
          onClick={() => history.current.undo()}
          icon="undo"
          tooltip="æ’¤é”€ (Ctrl+Z)"
        />
        <ToolbarButton
          disabled={!canRedo}
          onClick={() => history.current.redo()}
          icon="redo"
          tooltip="é‡åš (Ctrl+Shift+Z)"
        />
      </Toolbar>

      {/* ç¼–è¾‘å™¨ä¸»ä½“ */}
      <EditorContent />
    </div>
  );
};
```

### 2. å¯Œæ–‡æœ¬æ ¼å¼åŠŸèƒ½

#### è®¾è®¡æ–¹æ¡ˆ

**ä½¿ç”¨ Selection API + document.execCommand()**

```typescript
// src/web/editor/rich-text-editor.ts

export class RichTextEditor {
  private selection: Selection | null = null;

  constructor(private contentEditable: HTMLElement) {
    this.selection = window.getSelection();
  }

  // åŠ ç²—
  bold() {
    document.execCommand('bold', false);
    this.notifyChange();
  }

  // æ–œä½“
  italic() {
    document.execCommand('italic', false);
    this.notifyChange();
  }

  // ä¸‹åˆ’çº¿
  underline() {
    document.execCommand('underline', false);
    this.notifyChange();
  }

  // æ ‡é¢˜
  setHeading(level: 1 | 2 | 3 | 4 | 5 | 6) {
    document.execCommand('formatBlock', false, `h${level}`);
    this.notifyChange();
  }

  // æœ‰åºåˆ—è¡¨
  insertOrderedList() {
    document.execCommand('insertOrderedList', false);
    this.notifyChange();
  }

  // æ— åºåˆ—è¡¨
  insertUnorderedList() {
    document.execCommand('insertUnorderedList', false);
    this.notifyChange();
  }

  // ç§»é™¤æ ¼å¼
  removeFormat() {
    document.execCommand('removeFormat', false);
    this.notifyChange();
  }

  // æ£€æŸ¥å½“å‰æ ¼å¼çŠ¶æ€
  getFormatState() {
    return {
      bold: document.queryCommandState('bold'),
      italic: document.queryCommandState('italic'),
      underline: document.queryCommandState('underline'),
      // ... å…¶ä»–çŠ¶æ€
    };
  }

  private notifyChange() {
    // è§¦å‘å†…å®¹å˜æ›´äº‹ä»¶
    const event = new CustomEvent('content-change', {
      detail: { content: this.contentEditable.innerHTML },
    });
    this.contentEditable.dispatchEvent(event);
  }
}
```

**æ ¼å¼å·¥å…·æ ç»„ä»¶**:

```typescript
// src/web/components/format-toolbar.tsx

interface FormatToolbarProps {
  onFormatChange?: (format: FormatState) => void;
}

export const FormatToolbar: React.FC<FormatToolbarProps> = ({ onFormatChange }) => {
  const editor = useRichTextEditor();
  const [formatState, setFormatState] = useState<FormatState>({
    bold: false,
    italic: false,
    underline: false,
    heading: null,
  });

  // ç›‘å¬é€‰åŒºå˜åŒ–ï¼Œæ›´æ–°æ ¼å¼çŠ¶æ€
  useEffect(() => {
    const updateFormatState = () => {
      setFormatState(editor.getFormatState());
    };

    document.addEventListener('selectionchange', updateFormatState);
    return () => document.removeEventListener('selectionchange', updateFormatState);
  }, [editor]);

  const handleFormat = (format: string) => {
    switch (format) {
      case 'bold':
        editor.bold();
        break;
      case 'italic':
        editor.italic();
        break;
      case 'underline':
        editor.underline();
        break;
      case 'h1':
      case 'h2':
      case 'h3':
      case 'h4':
      case 'h5':
      case 'h6':
        editor.setHeading(parseInt(format[1]));
        break;
      // ... å…¶ä»–æ ¼å¼
    }

    // æ›´æ–°çŠ¶æ€
    setFormatState(editor.getFormatState());
    onFormatChange?.(editor.getFormatState());
  };

  return (
    <div className="format-toolbar">
      <ToolbarButton
        active={formatState.bold}
        onClick={() => handleFormat('bold')}
        icon="bold"
        tooltip="ç²—ä½“ (Ctrl+B)"
      />
      <ToolbarButton
        active={formatState.italic}
        onClick={() => handleFormat('italic')}
        icon="italic"
        tooltip="æ–œä½“ (Ctrl+I)"
      />
      <ToolbarButton
        active={formatState.underline}
        onClick={() => handleFormat('underline')}
        icon="underline"
        tooltip="ä¸‹åˆ’çº¿ (Ctrl+U)"
      />

      <ToolbarSeparator />

      <HeadingSelect
        value={formatState.heading}
        onChange={(level) => handleFormat(`h${level}`)}
      />

      <ToolbarSeparator />

      <ToolbarButton
        onClick={() => handleFormat('insertOrderedList')}
        icon="list-ordered"
        tooltip="æœ‰åºåˆ—è¡¨"
      />
      <ToolbarButton
        onClick={() => handleFormat('insertUnorderedList')}
        icon="list-unordered"
        tooltip="æ— åºåˆ—è¡¨"
      />
    </div>
  );
};
```

### 3. é¢„è§ˆæ¨¡å¼

#### è®¾è®¡æ–¹æ¡ˆ

```typescript
// src/web/components/preview-mode.tsx

interface PreviewModeProps {
  content: Block[];
  onEdit: () => void;
}

export const PreviewMode: React.FC<PreviewModeProps> = ({ content, onEdit }) => {
  return (
    <div className="preview-mode">
      {/* é¢„è§ˆå·¥å…·æ  */}
      <div className="preview-toolbar">
        <button onClick={onEdit} className="edit-button">
          <EditIcon /> è¿”å›ç¼–è¾‘
        </button>
        <div className="preview-actions">
          <button onClick={() => window.print()} title="æ‰“å°">
            <PrintIcon />
          </button>
          <button onClick={handleExportPDF} title="å¯¼å‡ºPDF">
            <PDFIcon />
          </button>
        </div>
      </div>

      {/* é¢„è§ˆå†…å®¹ */}
      <div className="preview-content">
        {content.map((block) => (
          <PreviewBlock key={block.id} block={block} />
        ))}
      </div>
    </div>
  );
};

const PreviewBlock: React.FC<{ block: Block }> = ({ block }) => {
  switch (block.type) {
    case 'h1':
      return <h1>{block.content}</h1>;
    case 'h2':
      return <h2>{block.content}</h2>;
    case 'paragraph':
      return <p>{block.content}</p>;
    case 'code':
      return (
        <CodeHighlight
          code={block.content}
          language={block.props?.language || 'javascript'}
        />
      );
    case 'list':
      return <ul>{block.children.map(child => <li key={child.id}>{child.content}</li>)}</ul>;
    default:
      return <div>{block.content}</div>;
  }
};
```

### 4. æ®µè½é—´è·å’Œå¯¹é½

#### è®¾è®¡æ–¹æ¡ˆ

```typescript
// src/web/components/paragraph-settings.tsx

interface ParagraphSettingsProps {
  blockId: string;
  onChange: (settings: ParagraphSettings) => void;
}

interface ParagraphSettings {
  lineHeight: number;      // è¡Œé«˜ 1.0-3.0
  letterSpacing: number;   // å­—é—´è· -2px-10px
  textAlign: 'left' | 'center' | 'right' | 'justify';
  marginTop: number;      // ä¸Šè¾¹è· 0-100px
  marginBottom: number;   // ä¸‹è¾¹è· 0-100px
}

export const ParagraphSettings: React.FC<ParagraphSettingsProps> = ({
  blockId,
  onChange
}) => {
  const [settings, setSettings] = useState<ParagraphSettings>({
    lineHeight: 1.5,
    letterSpacing: 0,
    textAlign: 'left',
    marginTop: 8,
    marginBottom: 8,
  });

  const handleChange = (key: keyof ParagraphSettings, value: any) => {
    const newSettings = { ...settings, [key]: value };
    setSettings(newSettings);
    onChange(newSettings);
  };

  return (
    <div className="paragraph-settings">
      {/* å¯¹é½æ–¹å¼ */}
      <div className="setting-group">
        <label>å¯¹é½æ–¹å¼</label>
        <ButtonGroup>
          <Button
            active={settings.textAlign === 'left'}
            onClick={() => handleChange('textAlign', 'left')}
          >
            å·¦å¯¹é½
          </Button>
          <Button
            active={settings.textAlign === 'center'}
            onClick={() => handleChange('textAlign', 'center')}
          >
            å±…ä¸­
          </Button>
          <Button
            active={settings.textAlign === 'right'}
            onClick={() => handleChange('textAlign', 'right')}
          >
            å³å¯¹é½
          </Button>
          <Button
            active={settings.textAlign === 'justify'}
            onClick={() => handleChange('textAlign', 'justify')}
          >
            ä¸¤ç«¯å¯¹é½
          </Button>
        </ButtonGroup>
      </div>

      {/* è¡Œé«˜ */}
      <div className="setting-group">
        <label>è¡Œé«˜: {settings.lineHeight}</label>
        <Slider
          min={1.0}
          max={3.0}
          step={0.1}
          value={settings.lineHeight}
          onChange={(value) => handleChange('lineHeight', value)}
        />
      </div>

      {/* å­—é—´è· */}
      <div className="setting-group">
        <label>å­—é—´è·: {settings.letterSpacing}px</label>
        <Slider
          min={-2}
          max={10}
          step={0.5}
          value={settings.letterSpacing}
          onChange={(value) => handleChange('letterSpacing', value)}
        />
      </div>

      {/* æ®µè½é—´è· */}
      <div className="setting-group">
        <label>æ®µè½é—´è·</label>
        <div className="spacing-inputs">
          <NumberInput
            label="ä¸Š"
            unit="px"
            value={settings.marginTop}
            onChange={(value) => handleChange('marginTop', value)}
          />
          <NumberInput
            label="ä¸‹"
            unit="px"
            value={settings.marginBottom}
            onChange={(value) => handleChange('marginBottom', value)}
          />
        </div>
      </div>
    </div>
  );
};
```

**åº”ç”¨æ ·å¼**:

```typescript
// æ ·å¼åº”ç”¨åˆ°å—
const applyParagraphStyles = (block: Block, settings: ParagraphSettings) => {
  return {
    ...block,
    style: {
      lineHeight: settings.lineHeight,
      letterSpacing: `${settings.letterSpacing}px`,
      textAlign: settings.textAlign,
      marginTop: `${settings.marginTop}px`,
      marginBottom: `${settings.marginBottom}px`,
    },
  };
};
```

### 5. ä»£ç è¯­æ³•é«˜äº®

#### è®¾è®¡æ–¹æ¡ˆ

**ä½¿ç”¨ Shikiï¼ˆæ¨èï¼‰æˆ– Prism.js**

```typescript
// src/web/lib/code-highlight.ts

import { codeToHtml } from 'shiki';

export class CodeHighlighter {
  private highlighter: any = null;
  private ready: Promise<void>;

  constructor() {
    this.ready = this.initHighlighter();
  }

  private async initHighlighter() {
    const { createHighlighter } = await import('shiki');
    this.highlighter = await createHighlighter({
      themes: ['github-light', 'github-dark'],
      langs: ['javascript', 'typescript', 'jsx', 'tsx', 'html', 'css', 'markdown', 'python', 'java', 'go', 'rust'],
    });
  }

  async highlight(code: string, lang: string, theme: 'light' | 'dark' = 'light') {
    await this.ready;

    const html = this.highlighter.codeToHtml(code, {
      lang: lang || 'text',
      theme: theme === 'dark' ? 'github-dark' : 'github-light',
    });

    return html;
  }
}

// å•ä¾‹å®ä¾‹
export const codeHighlighter = new CodeHighlighter();
```

**ä»£ç å—ç»„ä»¶**:

```typescript
// src/web/components/code-block.tsx

interface CodeBlockProps {
  code: string;
  language?: string;
  theme?: 'light' | 'dark';
}

export const CodeBlock: React.FC<CodeBlockProps> = ({
  code,
  language = 'javascript',
  theme = 'light'
}) => {
  const [highlightedCode, setHighlightedCode] = useState<string>('');
  const [loading, setLoading] = useState(true);

  useEffect(() => {
    codeHighlighter.highlight(code, language, theme).then(html => {
      setHighlightedCode(html);
      setLoading(false);
    });
  }, [code, language, theme]);

  if (loading) {
    return <pre className="code-block loading">{code}</pre>;
  }

  return (
    <div className="code-block-wrapper">
      <div className="code-header">
        <span className="language-badge">{language}</span>
        <CopyButton text={code} />
      </div>
      <div
        className="code-content"
        dangerouslySetInnerHTML={{ __html: highlightedCode }}
      />
    </div>
  );
};
```

**Shadow DOM æ ·å¼éš”ç¦»**ï¼ˆåµŒå…¥åœºæ™¯ï¼‰:

```typescript
// ç¡®ä¿é«˜äº®æ ·å¼ä¸ä¸å®¿ä¸»åº”ç”¨å†²çª
export const CodeBlockShadow: React.FC<CodeBlockProps> = (props) => {
  const shadowRoot = useRef<HTMLDivElement>(null);
  const shadowHost = useRef<HTMLDivElement>(null);

  useEffect(() => {
    if (shadowHost.current && !shadowHost.current.shadowRoot) {
      const shadow = shadowHost.current.attachShadow({ mode: 'open' });
      shadow.innerHTML = `
        <style>
          /* Shiki æ ·å¼éš”ç¦» */
          .shiki { padding: 1em; }
          /* å…¶ä»–æ ·å¼... */
        </style>
        <div class="code-container"></div>
      `;
      shadowRoot.current = shadow.querySelector('.code-container') as HTMLDivElement;
    }
  }, []);

  useEffect(() => {
    if (shadowRoot.current) {
      codeHighlighter.highlight(props.code, props.language).then(html => {
        shadowRoot.current!.innerHTML = html;
      });
    }
  }, [props.code, props.language]);

  return <div ref={shadowHost} className="code-block-shadow" />;
};
```

---

## æŠ€æœ¯å®ç°æ–¹æ¡ˆ

### ç»„ä»¶é‡æ„è®¡åˆ’

```typescript
// src/web/components/blocksuite-editor.tsx (é‡æ„å)

interface BlocksuiteEditorProps {
  docId: string;
  mode: 'edit' | 'preview';
  onModeChange?: (mode: 'edit' | 'preview') => void;
}

export const BlocksuiteEditor: React.FC<BlocksuiteEditorProps> = ({
  docId,
  mode,
  onModeChange
}) => {
  // å†å²ç®¡ç†å™¨
  const history = useEditorHistory();

  // å¯Œæ–‡æœ¬ç¼–è¾‘å™¨
  const richText = useRichTextEditor();

  // ä»£ç é«˜äº®
  const highlighter = useCodeHighlighter();

  // æ’¤é”€/é‡åšçŠ¶æ€
  const { canUndo, canRedo, undo, redo } = history;

  return (
    <div className="blocksuite-editor" data-mode={mode}>
      {/* å·¥å…·æ  */}
      {mode === 'edit' && (
        <>
          <FormatToolbar
            formatState={richText.getFormatState()}
            onFormat={richText.executeFormat}
          />
          <EditToolbar
            canUndo={canUndo}
            canRedo={canRedo}
            onUndo={undo}
            onRedo={redo}
            onPreview={() => onModeChange?.('preview')}
          />
        </>
      )}

      {/* ç¼–è¾‘/é¢„è§ˆæ¨¡å¼åˆ‡æ¢ */}
      {mode === 'preview' ? (
        <PreviewMode
          content={blocks}
          onEdit={() => onModeChange?.('edit')}
        />
      ) : (
        <EditorContent
          blocks={blocks}
          onBlockChange={handleBlockChange}
          richText={richText}
          highlighter={highlighter}
        />
      )}

      {/* çŠ¶æ€æ  */}
      <StatusBar
        wordCount={wordCount}
        lastSaved={lastSaved}
        saveStatus={saveStatus}
      />
    </div>
  );
};
```

### Hook å®ç°

```typescript
// src/web/hooks/use-editor-history.ts

export const useEditorHistory = () => {
  const history = useMemo(() => new HistoryManager(), []);

  const undo = useCallback(() => history.undo(), [history]);
  const redo = useCallback(() => history.redo(), [history]);
  const canUndo = useCallback(() => history.canUndo(), [history]);
  const canRedo = useCallback(() => history.canRedo(), [history]);

  return {
    undo,
    redo,
    canUndo: canUndo(),
    canRedo: canRedo(),
    execute: (command: EditorCommand) => history.execute(command),
  };
};

// src/web/hooks/use-rich-text-editor.ts

export const useRichTextEditor = () => {
  const editor = useMemo(() => new RichTextEditor(contentEditable), []);

  const getFormatState = useCallback(() => editor.getFormatState(), [editor]);
  const executeFormat = useCallback(
    (format: string, ...args: any[]) => {
      switch (format) {
        case 'bold':
          editor.bold();
          break;
        // ... å…¶ä»–æ ¼å¼
      }
    },
    [editor]
  );

  return {
    getFormatState,
    executeFormat,
  };
};
```

---

## APIå¯¹æ¥

### ä¸åç«¯åŒæ­¥

```typescript
// src/web/services/document-sync.ts

export class DocumentSyncService {
  private docId: string;
  private lastSyncTime: number = 0;
  private syncInterval: number = 5000; // 5ç§’

  async syncContent(content: Block[]): Promise<void> {
    try {
      await documentService.updateDoc(this.docId, {
        content: JSON.stringify(content),
      });

      this.lastSyncTime = Date.now();
      this.updateSaveStatus('saved');
    } catch (error) {
      this.updateSaveStatus('error');
      throw error;
    }
  }

  // è‡ªåŠ¨åŒæ­¥
  startAutoSync(getContent: () => Block[]) {
    const intervalId = setInterval(async () => {
      try {
        await this.syncContent(getContent());
      } catch (error) {
        console.error('Auto sync failed:', error);
      }
    }, this.syncInterval);

    return () => clearInterval(intervalId);
  }

  // æ‰‹åŠ¨ä¿å­˜
  async manualSave(content: Block[]) {
    await this.syncContent(content);
  }
}
```

---

## æ€§èƒ½ä¼˜åŒ–

### å¤§æ–‡æ¡£ä¼˜åŒ–

```typescript
// è™šæ‹Ÿæ»šåŠ¨æ¸²æŸ“
import { useVirtualizer } from '@tanstack/react-virtual';

export const VirtualizedEditor: React.FC<{ blocks: Block[] }> = ({ blocks }) => {
  const parentRef = useRef<HTMLDivElement>(null);

  const virtualizer = useVirtualizer({
    count: blocks.length,
    getScrollElement: () => parentRef.current,
    estimateSize: () => 50, // ä¼°è®¡æ¯ä¸ªå—é«˜åº¦
    overscan: 5, // é¢„æ¸²æŸ“5ä¸ªå—
  });

  return (
    <div ref={parentRef} className="editor-scroll-container" style={{ height: '100vh' }}>
      <div style={{ height: `${virtualizer.getTotalSize()}px` }}>
        {virtualizer.getVirtualItems().map((virtualBlock) => {
          const block = blocks[virtualBlock.index];
          return (
            <div
              key={virtualBlock.key}
              style={{
                position: 'absolute',
                top: 0,
                left: 0,
                width: '100%',
                height: `${virtualBlock.size}px`,
                transform: `translateY(${virtualBlock.start}px)`,
              }}
            >
              <BlockRenderer block={block} />
            </div>
          );
        })}
      </div>
    </div>
  );
};
```

### é˜²æŠ–ä¿å­˜

```typescript
import { debounce } from 'lodash-es';

// é˜²æŠ–ä¿å­˜ï¼ˆ5ç§’å†…æ— æ›´æ”¹æ‰ä¿å­˜ï¼‰
const debouncedSave = debounce(async content => {
  await documentService.updateDoc(docId, { content });
}, 5000);
```

---

## å®ç°ä¼˜å…ˆçº§

### Phase 1: æ ¸å¿ƒåŠŸèƒ½ï¼ˆå¿…é¡»å®ç°ï¼‰

- [ ] æ’¤é”€/é‡åšï¼ˆ50æ­¥å†å²ï¼‰
- [ ] å¯Œæ–‡æœ¬æ ¼å¼ï¼ˆç²—ä½“/æ–œä½“/ä¸‹åˆ’çº¿ï¼‰
- [ ] æ ¼å¼å·¥å…·æ 

### Phase 2: å¢å¼ºåŠŸèƒ½ï¼ˆé‡è¦ï¼‰

- [ ] é¢„è§ˆæ¨¡å¼
- [ ] æ®µè½é—´è·å’Œå¯¹é½
- [ ] ä»£ç è¯­æ³•é«˜äº®

### Phase 3: ä¼˜åŒ–åŠŸèƒ½ï¼ˆå¯é€‰ï¼‰

- [ ] è™šæ‹Ÿæ»šåŠ¨ï¼ˆå¤§æ–‡æ¡£æ€§èƒ½ï¼‰
- [ ] é”®ç›˜å¿«æ·é”®æ‰©å±•
- [ ] æ›´å¤šæ ¼å¼é€‰é¡¹

---

**æ–‡æ¡£ç‰ˆæœ¬**: 1.0
**æœ€åæ›´æ–°**: 2025-01-16
**é¢„è®¡å·¥æ—¶**: Phase 1 (3-4å¤©), Phase 2 (2-3å¤©), Phase 3 (2-3å¤©)
